//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g 2014-03-10 16:22:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using TigerCompiler.ErrorHandling;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_TYPE_DECLARATION", "AND", "ARRAY", "ARRAY_INDEX", "ARRAY_TYPE_DECLARATION", "ASSIGN", "BREAK", "COLON", "COMMA", "COMMENT", "DIGIT", "DIV", "DO", "DOT", "ELSE", "END", "EQUAL", "ESC_SEQ", "EXPRESSION", "EXPRESSION_SEQ", "FOR", "FUNCTION", "FUNCTION_DECLARATION", "GREATER_EQUAL_THAN", "GREATER_THAN", "IDENTIFIER", "IF", "IF_THEN", "IF_THEN_ELSE", "IN", "INT", "LBRACE", "LBRACKET", "LESS_EQUAL_THAN", "LESS_THAN", "LET", "LETTER", "LPARENTHESIS", "LVALUE", "MINUS", "MULT", "NEGATE", "NIL", "NOT_EQUAL", "OF", "OR", "PLUS", "RBRACE", "RBRACKET", "RECORD", "RECORD_TYPE_DECLARATION", "RETURN_TYPE", "RPARENTHESIS", "SEMICOLON", "STRING", "THEN", "TO", "TYPE", "TYPE_DECLARATION", "TYPE_DECLARATION_FIELD", "VAR", "VAR_DECLARATION", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ALIAS_TYPE_DECLARATION=4;
	public const int AND=5;
	public const int ARRAY=6;
	public const int ARRAY_INDEX=7;
	public const int ARRAY_TYPE_DECLARATION=8;
	public const int ASSIGN=9;
	public const int BREAK=10;
	public const int COLON=11;
	public const int COMMA=12;
	public const int COMMENT=13;
	public const int DIGIT=14;
	public const int DIV=15;
	public const int DO=16;
	public const int DOT=17;
	public const int ELSE=18;
	public const int END=19;
	public const int EQUAL=20;
	public const int ESC_SEQ=21;
	public const int EXPRESSION=22;
	public const int EXPRESSION_SEQ=23;
	public const int FOR=24;
	public const int FUNCTION=25;
	public const int FUNCTION_DECLARATION=26;
	public const int GREATER_EQUAL_THAN=27;
	public const int GREATER_THAN=28;
	public const int IDENTIFIER=29;
	public const int IF=30;
	public const int IF_THEN=31;
	public const int IF_THEN_ELSE=32;
	public const int IN=33;
	public const int INT=34;
	public const int LBRACE=35;
	public const int LBRACKET=36;
	public const int LESS_EQUAL_THAN=37;
	public const int LESS_THAN=38;
	public const int LET=39;
	public const int LETTER=40;
	public const int LPARENTHESIS=41;
	public const int LVALUE=42;
	public const int MINUS=43;
	public const int MULT=44;
	public const int NEGATE=45;
	public const int NIL=46;
	public const int NOT_EQUAL=47;
	public const int OF=48;
	public const int OR=49;
	public const int PLUS=50;
	public const int RBRACE=51;
	public const int RBRACKET=52;
	public const int RECORD=53;
	public const int RECORD_TYPE_DECLARATION=54;
	public const int RETURN_TYPE=55;
	public const int RPARENTHESIS=56;
	public const int SEMICOLON=57;
	public const int STRING=58;
	public const int THEN=59;
	public const int TO=60;
	public const int TYPE=61;
	public const int TYPE_DECLARATION=62;
	public const int TYPE_DECLARATION_FIELD=63;
	public const int VAR=64;
	public const int VAR_DECLARATION=65;
	public const int WHILE=66;
	public const int WS=67;

	public TigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g"; } }


	public override void ReportError(RecognitionException exc) { 
		Errors.AddSintacticError(exc, TokenNames);
	} 


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:126:8: public program : expr EOF -> ^( EXPRESSION expr ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(126, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:127:2: ( expr EOF -> ^( EXPRESSION expr ) )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:127:4: expr EOF
			{
			DebugLocation(127, 4);
			PushFollow(Follow._expr_in_program685);
			expr1=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr1.Tree);
			DebugLocation(127, 9);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program687); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 127:13: -> ^( EXPRESSION expr )
			{
				DebugLocation(127, 16);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:127:16: ^( EXPRESSION expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(127, 18);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(127, 29);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:1: expr : conjunction_term ( ( OR ^| AND ^) conjunction_term )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR4 = default(IToken);
		IToken AND5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> conjunction_term3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> conjunction_term6 = default(AstParserRuleReturnScope<object, IToken>);

		object OR4_tree = default(object);
		object AND5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(129, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:6: ( conjunction_term ( ( OR ^| AND ^) conjunction_term )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:8: conjunction_term ( ( OR ^| AND ^) conjunction_term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(129, 8);
			PushFollow(Follow._conjunction_term_in_expr704);
			conjunction_term3=conjunction_term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, conjunction_term3.Tree);
			DebugLocation(129, 25);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:25: ( ( OR ^| AND ^) conjunction_term )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==OR))
				{
					alt2 = 1;
				}
				else if ((LA2_0==AND))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:26: ( OR ^| AND ^) conjunction_term
					{
					DebugLocation(129, 26);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:26: ( OR ^| AND ^)
					int alt1=2;
					try { DebugEnterSubRule(1);
					try { DebugEnterDecision(1, false);
					int LA1_0 = input.LA(1);

					if ((LA1_0==OR))
					{
						alt1 = 1;
					}
					else if ((LA1_0==AND))
					{
						alt1 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(1); }
					switch (alt1)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:27: OR ^
						{
						DebugLocation(129, 29);
						OR4=(IToken)Match(input,OR,Follow._OR_in_expr708); if (state.failed) return retval;
						if (state.backtracking == 0) {
						OR4_tree = (object)adaptor.Create(OR4);
						root_0 = (object)adaptor.BecomeRoot(OR4_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:129:31: AND ^
						{
						DebugLocation(129, 34);
						AND5=(IToken)Match(input,AND,Follow._AND_in_expr711); if (state.failed) return retval;
						if (state.backtracking == 0) {
						AND5_tree = (object)adaptor.Create(AND5);
						root_0 = (object)adaptor.BecomeRoot(AND5_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(1); }

					DebugLocation(129, 37);
					PushFollow(Follow._conjunction_term_in_expr715);
					conjunction_term6=conjunction_term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, conjunction_term6.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_conjunction_term();
	partial void LeaveRule_conjunction_term();

	// $ANTLR start "conjunction_term"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:131:1: conjunction_term : comparison_term ( ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^) comparison_term )* ;
	[GrammarRule("conjunction_term")]
	private AstParserRuleReturnScope<object, IToken> conjunction_term()
	{
		EnterRule_conjunction_term();
		EnterRule("conjunction_term", 3);
		TraceIn("conjunction_term", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUAL8 = default(IToken);
		IToken NOT_EQUAL9 = default(IToken);
		IToken LESS_THAN10 = default(IToken);
		IToken GREATER_THAN11 = default(IToken);
		IToken LESS_EQUAL_THAN12 = default(IToken);
		IToken GREATER_EQUAL_THAN13 = default(IToken);
		AstParserRuleReturnScope<object, IToken> comparison_term7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> comparison_term14 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUAL8_tree = default(object);
		object NOT_EQUAL9_tree = default(object);
		object LESS_THAN10_tree = default(object);
		object GREATER_THAN11_tree = default(object);
		object LESS_EQUAL_THAN12_tree = default(object);
		object GREATER_EQUAL_THAN13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conjunction_term");
		DebugLocation(131, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:2: ( comparison_term ( ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^) comparison_term )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:4: comparison_term ( ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^) comparison_term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(132, 4);
			PushFollow(Follow._comparison_term_in_conjunction_term727);
			comparison_term7=comparison_term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, comparison_term7.Tree);
			DebugLocation(132, 20);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:20: ( ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^) comparison_term )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case EQUAL:
					{
					alt4 = 1;
					}
					break;
				case NOT_EQUAL:
					{
					alt4 = 1;
					}
					break;
				case LESS_THAN:
					{
					alt4 = 1;
					}
					break;
				case GREATER_THAN:
					{
					alt4 = 1;
					}
					break;
				case LESS_EQUAL_THAN:
					{
					alt4 = 1;
					}
					break;
				case GREATER_EQUAL_THAN:
					{
					alt4 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:21: ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^) comparison_term
					{
					DebugLocation(132, 21);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:21: ( EQUAL ^| NOT_EQUAL ^| LESS_THAN ^| GREATER_THAN ^| LESS_EQUAL_THAN ^| GREATER_EQUAL_THAN ^)
					int alt3=6;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					switch (input.LA(1))
					{
					case EQUAL:
						{
						alt3 = 1;
						}
						break;
					case NOT_EQUAL:
						{
						alt3 = 2;
						}
						break;
					case LESS_THAN:
						{
						alt3 = 3;
						}
						break;
					case GREATER_THAN:
						{
						alt3 = 4;
						}
						break;
					case LESS_EQUAL_THAN:
						{
						alt3 = 5;
						}
						break;
					case GREATER_EQUAL_THAN:
						{
						alt3 = 6;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:22: EQUAL ^
						{
						DebugLocation(132, 27);
						EQUAL8=(IToken)Match(input,EQUAL,Follow._EQUAL_in_conjunction_term731); if (state.failed) return retval;
						if (state.backtracking == 0) {
						EQUAL8_tree = (object)adaptor.Create(EQUAL8);
						root_0 = (object)adaptor.BecomeRoot(EQUAL8_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:29: NOT_EQUAL ^
						{
						DebugLocation(132, 38);
						NOT_EQUAL9=(IToken)Match(input,NOT_EQUAL,Follow._NOT_EQUAL_in_conjunction_term734); if (state.failed) return retval;
						if (state.backtracking == 0) {
						NOT_EQUAL9_tree = (object)adaptor.Create(NOT_EQUAL9);
						root_0 = (object)adaptor.BecomeRoot(NOT_EQUAL9_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:40: LESS_THAN ^
						{
						DebugLocation(132, 49);
						LESS_THAN10=(IToken)Match(input,LESS_THAN,Follow._LESS_THAN_in_conjunction_term737); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LESS_THAN10_tree = (object)adaptor.Create(LESS_THAN10);
						root_0 = (object)adaptor.BecomeRoot(LESS_THAN10_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:51: GREATER_THAN ^
						{
						DebugLocation(132, 63);
						GREATER_THAN11=(IToken)Match(input,GREATER_THAN,Follow._GREATER_THAN_in_conjunction_term740); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GREATER_THAN11_tree = (object)adaptor.Create(GREATER_THAN11);
						root_0 = (object)adaptor.BecomeRoot(GREATER_THAN11_tree, root_0);
						}

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:65: LESS_EQUAL_THAN ^
						{
						DebugLocation(132, 80);
						LESS_EQUAL_THAN12=(IToken)Match(input,LESS_EQUAL_THAN,Follow._LESS_EQUAL_THAN_in_conjunction_term743); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LESS_EQUAL_THAN12_tree = (object)adaptor.Create(LESS_EQUAL_THAN12);
						root_0 = (object)adaptor.BecomeRoot(LESS_EQUAL_THAN12_tree, root_0);
						}

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:132:82: GREATER_EQUAL_THAN ^
						{
						DebugLocation(132, 100);
						GREATER_EQUAL_THAN13=(IToken)Match(input,GREATER_EQUAL_THAN,Follow._GREATER_EQUAL_THAN_in_conjunction_term746); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GREATER_EQUAL_THAN13_tree = (object)adaptor.Create(GREATER_EQUAL_THAN13);
						root_0 = (object)adaptor.BecomeRoot(GREATER_EQUAL_THAN13_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(132, 103);
					PushFollow(Follow._comparison_term_in_conjunction_term750);
					comparison_term14=comparison_term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, comparison_term14.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conjunction_term", 3);
			LeaveRule("conjunction_term", 3);
			LeaveRule_conjunction_term();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "conjunction_term"); }
		return retval;

	}
	// $ANTLR end "conjunction_term"

	partial void EnterRule_comparison_term();
	partial void LeaveRule_comparison_term();

	// $ANTLR start "comparison_term"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:134:1: comparison_term : term ( ( PLUS ^| MINUS ^) term )* ;
	[GrammarRule("comparison_term")]
	private AstParserRuleReturnScope<object, IToken> comparison_term()
	{
		EnterRule_comparison_term();
		EnterRule("comparison_term", 4);
		TraceIn("comparison_term", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS16 = default(IToken);
		IToken MINUS17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term18 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS16_tree = default(object);
		object MINUS17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "comparison_term");
		DebugLocation(134, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:2: ( term ( ( PLUS ^| MINUS ^) term )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:4: term ( ( PLUS ^| MINUS ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(135, 4);
			PushFollow(Follow._term_in_comparison_term762);
			term15=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term15.Tree);
			DebugLocation(135, 9);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:9: ( ( PLUS ^| MINUS ^) term )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==PLUS))
				{
					alt6 = 1;
				}
				else if ((LA6_0==MINUS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:10: ( PLUS ^| MINUS ^) term
					{
					DebugLocation(135, 10);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:10: ( PLUS ^| MINUS ^)
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==PLUS))
					{
						alt5 = 1;
					}
					else if ((LA5_0==MINUS))
					{
						alt5 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:11: PLUS ^
						{
						DebugLocation(135, 15);
						PLUS16=(IToken)Match(input,PLUS,Follow._PLUS_in_comparison_term766); if (state.failed) return retval;
						if (state.backtracking == 0) {
						PLUS16_tree = (object)adaptor.Create(PLUS16);
						root_0 = (object)adaptor.BecomeRoot(PLUS16_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:135:17: MINUS ^
						{
						DebugLocation(135, 22);
						MINUS17=(IToken)Match(input,MINUS,Follow._MINUS_in_comparison_term769); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MINUS17_tree = (object)adaptor.Create(MINUS17);
						root_0 = (object)adaptor.BecomeRoot(MINUS17_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(135, 25);
					PushFollow(Follow._term_in_comparison_term773);
					term18=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term18.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comparison_term", 4);
			LeaveRule("comparison_term", 4);
			LeaveRule_comparison_term();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "comparison_term"); }
		return retval;

	}
	// $ANTLR end "comparison_term"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:1: term : ( atom | atom DIV )=> atom ( ( MULT ^| DIV ^) atom )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 5);
		TraceIn("term", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MULT20 = default(IToken);
		IToken DIV21 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom22 = default(AstParserRuleReturnScope<object, IToken>);

		object MULT20_tree = default(object);
		object DIV21_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(137, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:6: ( ( atom | atom DIV )=> atom ( ( MULT ^| DIV ^) atom )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:8: ( atom | atom DIV )=> atom ( ( MULT ^| DIV ^) atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(137, 29);
			PushFollow(Follow._atom_in_term796);
			atom19=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, atom19.Tree);
			DebugLocation(137, 34);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:34: ( ( MULT ^| DIV ^) atom )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MULT))
				{
					alt8 = 1;
				}
				else if ((LA8_0==DIV))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:35: ( MULT ^| DIV ^) atom
					{
					DebugLocation(137, 35);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:35: ( MULT ^| DIV ^)
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==MULT))
					{
						alt7 = 1;
					}
					else if ((LA7_0==DIV))
					{
						alt7 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:36: MULT ^
						{
						DebugLocation(137, 40);
						MULT20=(IToken)Match(input,MULT,Follow._MULT_in_term800); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MULT20_tree = (object)adaptor.Create(MULT20);
						root_0 = (object)adaptor.BecomeRoot(MULT20_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:137:44: DIV ^
						{
						DebugLocation(137, 47);
						DIV21=(IToken)Match(input,DIV,Follow._DIV_in_term805); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DIV21_tree = (object)adaptor.Create(DIV21);
						root_0 = (object)adaptor.BecomeRoot(DIV21_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(137, 50);
					PushFollow(Follow._atom_in_term809);
					atom22=atom();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, atom22.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 5);
			LeaveRule("term", 5);
			LeaveRule_term();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:139:1: atom : ( flow_instructions | ( lvalue ASSIGN )=> lvalue ASSIGN expr -> ^( ASSIGN lvalue expr ) | ( type_id LBRACE )=> type_id LBRACE ( field_list )? RBRACE -> ^( RECORD[((CommonTree)$type_id.tree).Token, \"RECORD\"] type_id ( field_list )? ) | ( type_id LBRACKET expr RBRACKET OF )=> type_id LBRACKET a= expr RBRACKET OF b= expr -> ^( ARRAY[((CommonTree)$type_id.tree).Token, \"ARRAY\"] type_id $a $b) | ( IDENTIFIER LPARENTHESIS )=> IDENTIFIER LPARENTHESIS ( expr_list )? RPARENTHESIS -> ^( FUNCTION[$IDENTIFIER, \"FUNCTION\"] IDENTIFIER ( expr_list )? ) | ( MINUS INT )=> MINUS INT -> ^( NEGATE[$MINUS, \"NEGATE\"] INT ) | LPARENTHESIS ( expr_seq )? RPARENTHESIS -> ^( EXPRESSION_SEQ[$LPARENTHESIS, \"EXPRESSION_SEQ\"] ( expr_seq )? ) | INT | NIL | STRING | BREAK | MINUS lvalue -> ^( NEGATE[$MINUS, \"NEGATE\"] lvalue ) | lvalue );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 6);
		TraceIn("atom", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN25 = default(IToken);
		IToken LBRACE28 = default(IToken);
		IToken RBRACE30 = default(IToken);
		IToken LBRACKET32 = default(IToken);
		IToken RBRACKET33 = default(IToken);
		IToken OF34 = default(IToken);
		IToken IDENTIFIER35 = default(IToken);
		IToken LPARENTHESIS36 = default(IToken);
		IToken RPARENTHESIS38 = default(IToken);
		IToken MINUS39 = default(IToken);
		IToken INT40 = default(IToken);
		IToken LPARENTHESIS41 = default(IToken);
		IToken RPARENTHESIS43 = default(IToken);
		IToken INT44 = default(IToken);
		IToken NIL45 = default(IToken);
		IToken STRING46 = default(IToken);
		IToken BREAK47 = default(IToken);
		IToken MINUS48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> b = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> flow_instructions23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr26 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field_list29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_list37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue50 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN25_tree = default(object);
		object LBRACE28_tree = default(object);
		object RBRACE30_tree = default(object);
		object LBRACKET32_tree = default(object);
		object RBRACKET33_tree = default(object);
		object OF34_tree = default(object);
		object IDENTIFIER35_tree = default(object);
		object LPARENTHESIS36_tree = default(object);
		object RPARENTHESIS38_tree = default(object);
		object MINUS39_tree = default(object);
		object INT40_tree = default(object);
		object LPARENTHESIS41_tree = default(object);
		object RPARENTHESIS43_tree = default(object);
		object INT44_tree = default(object);
		object NIL45_tree = default(object);
		object STRING46_tree = default(object);
		object BREAK47_tree = default(object);
		object MINUS48_tree = default(object);
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_RPARENTHESIS=new RewriteRuleITokenStream(adaptor,"token RPARENTHESIS");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPARENTHESIS=new RewriteRuleITokenStream(adaptor,"token LPARENTHESIS");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_lvalue=new RewriteRuleSubtreeStream(adaptor,"rule lvalue");
		RewriteRuleSubtreeStream stream_field_list=new RewriteRuleSubtreeStream(adaptor,"rule field_list");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		RewriteRuleSubtreeStream stream_expr_list=new RewriteRuleSubtreeStream(adaptor,"rule expr_list");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(139, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:139:6: ( flow_instructions | ( lvalue ASSIGN )=> lvalue ASSIGN expr -> ^( ASSIGN lvalue expr ) | ( type_id LBRACE )=> type_id LBRACE ( field_list )? RBRACE -> ^( RECORD[((CommonTree)$type_id.tree).Token, \"RECORD\"] type_id ( field_list )? ) | ( type_id LBRACKET expr RBRACKET OF )=> type_id LBRACKET a= expr RBRACKET OF b= expr -> ^( ARRAY[((CommonTree)$type_id.tree).Token, \"ARRAY\"] type_id $a $b) | ( IDENTIFIER LPARENTHESIS )=> IDENTIFIER LPARENTHESIS ( expr_list )? RPARENTHESIS -> ^( FUNCTION[$IDENTIFIER, \"FUNCTION\"] IDENTIFIER ( expr_list )? ) | ( MINUS INT )=> MINUS INT -> ^( NEGATE[$MINUS, \"NEGATE\"] INT ) | LPARENTHESIS ( expr_seq )? RPARENTHESIS -> ^( EXPRESSION_SEQ[$LPARENTHESIS, \"EXPRESSION_SEQ\"] ( expr_seq )? ) | INT | NIL | STRING | BREAK | MINUS lvalue -> ^( NEGATE[$MINUS, \"NEGATE\"] lvalue ) | lvalue )
			int alt12=13;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case FOR:
			case IF:
			case LET:
			case WHILE:
				{
				alt12 = 1;
				}
				break;
			case IDENTIFIER:
				{
				int LA12_5 = input.LA(2);

				if ((EvaluatePredicate(synpred2_Tiger_fragment)))
				{
					alt12 = 2;
				}
				else if ((EvaluatePredicate(synpred3_Tiger_fragment)))
				{
					alt12 = 3;
				}
				else if ((EvaluatePredicate(synpred4_Tiger_fragment)))
				{
					alt12 = 4;
				}
				else if ((EvaluatePredicate(synpred5_Tiger_fragment)))
				{
					alt12 = 5;
				}
				else if ((true))
				{
					alt12 = 13;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case MINUS:
				{
				int LA12_6 = input.LA(2);

				if ((EvaluatePredicate(synpred6_Tiger_fragment)))
				{
					alt12 = 6;
				}
				else if ((true))
				{
					alt12 = 12;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPARENTHESIS:
				{
				alt12 = 7;
				}
				break;
			case INT:
				{
				alt12 = 8;
				}
				break;
			case NIL:
				{
				alt12 = 9;
				}
				break;
			case STRING:
				{
				alt12 = 10;
				}
				break;
			case BREAK:
				{
				alt12 = 11;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:139:8: flow_instructions
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(139, 8);
				PushFollow(Follow._flow_instructions_in_atom820);
				flow_instructions23=flow_instructions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, flow_instructions23.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:140:4: ( lvalue ASSIGN )=> lvalue ASSIGN expr
				{
				DebugLocation(140, 23);
				PushFollow(Follow._lvalue_in_atom833);
				lvalue24=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lvalue.Add(lvalue24.Tree);
				DebugLocation(140, 30);
				ASSIGN25=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_atom835); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN25);

				DebugLocation(140, 37);
				PushFollow(Follow._expr_in_atom837);
				expr26=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr26.Tree);


				{
				// AST REWRITE
				// elements: lvalue, expr, ASSIGN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 140:42: -> ^( ASSIGN lvalue expr )
				{
					DebugLocation(140, 45);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:140:45: ^( ASSIGN lvalue expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(140, 47);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(140, 54);
					adaptor.AddChild(root_1, stream_lvalue.NextTree());
					DebugLocation(140, 61);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:4: ( type_id LBRACE )=> type_id LBRACE ( field_list )? RBRACE
				{
				DebugLocation(141, 24);
				PushFollow(Follow._type_id_in_atom860);
				type_id27=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id27.Tree);
				DebugLocation(141, 32);
				LBRACE28=(IToken)Match(input,LBRACE,Follow._LBRACE_in_atom862); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(LBRACE28);

				DebugLocation(141, 39);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:39: ( field_list )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==IDENTIFIER))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:39: field_list
					{
					DebugLocation(141, 39);
					PushFollow(Follow._field_list_in_atom864);
					field_list29=field_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_field_list.Add(field_list29.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(141, 51);
				RBRACE30=(IToken)Match(input,RBRACE,Follow._RBRACE_in_atom867); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE30);



				{
				// AST REWRITE
				// elements: field_list, type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 141:58: -> ^( RECORD[((CommonTree)$type_id.tree).Token, \"RECORD\"] type_id ( field_list )? )
				{
					DebugLocation(141, 61);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:61: ^( RECORD[((CommonTree)$type_id.tree).Token, \"RECORD\"] type_id ( field_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(141, 63);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD, ((CommonTree)(type_id27!=null?((object)type_id27.Tree):default(object))).Token, "RECORD"), root_1);

					DebugLocation(141, 115);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(141, 123);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:123: ( field_list )?
					if (stream_field_list.HasNext)
					{
						DebugLocation(141, 123);
						adaptor.AddChild(root_1, stream_field_list.NextTree());

					}
					stream_field_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:142:4: ( type_id LBRACKET expr RBRACKET OF )=> type_id LBRACKET a= expr RBRACKET OF b= expr
				{
				DebugLocation(142, 43);
				PushFollow(Follow._type_id_in_atom898);
				type_id31=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id31.Tree);
				DebugLocation(142, 51);
				LBRACKET32=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_atom900); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET32);

				DebugLocation(142, 61);
				PushFollow(Follow._expr_in_atom904);
				a=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(a.Tree);
				DebugLocation(142, 67);
				RBRACKET33=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_atom906); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET33);

				DebugLocation(142, 76);
				OF34=(IToken)Match(input,OF,Follow._OF_in_atom908); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OF.Add(OF34);

				DebugLocation(142, 80);
				PushFollow(Follow._expr_in_atom912);
				b=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(b.Tree);


				{
				// AST REWRITE
				// elements: b, type_id, a
				// token labels: 
				// rule labels: retval, b, a
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 142:86: -> ^( ARRAY[((CommonTree)$type_id.tree).Token, \"ARRAY\"] type_id $a $b)
				{
					DebugLocation(142, 89);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:142:89: ^( ARRAY[((CommonTree)$type_id.tree).Token, \"ARRAY\"] type_id $a $b)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(142, 91);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY, ((CommonTree)(type_id31!=null?((object)type_id31.Tree):default(object))).Token, "ARRAY"), root_1);

					DebugLocation(142, 141);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(142, 150);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(142, 153);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:4: ( IDENTIFIER LPARENTHESIS )=> IDENTIFIER LPARENTHESIS ( expr_list )? RPARENTHESIS
				{
				DebugLocation(143, 33);
				IDENTIFIER35=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_atom940); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER35);

				DebugLocation(143, 44);
				LPARENTHESIS36=(IToken)Match(input,LPARENTHESIS,Follow._LPARENTHESIS_in_atom942); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPARENTHESIS.Add(LPARENTHESIS36);

				DebugLocation(143, 57);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:57: ( expr_list )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==BREAK||LA10_0==FOR||(LA10_0>=IDENTIFIER && LA10_0<=IF)||LA10_0==INT||LA10_0==LET||LA10_0==LPARENTHESIS||LA10_0==MINUS||LA10_0==NIL||LA10_0==STRING||LA10_0==WHILE))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:57: expr_list
					{
					DebugLocation(143, 57);
					PushFollow(Follow._expr_list_in_atom944);
					expr_list37=expr_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_list.Add(expr_list37.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(143, 68);
				RPARENTHESIS38=(IToken)Match(input,RPARENTHESIS,Follow._RPARENTHESIS_in_atom947); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPARENTHESIS.Add(RPARENTHESIS38);



				{
				// AST REWRITE
				// elements: IDENTIFIER, expr_list
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 143:81: -> ^( FUNCTION[$IDENTIFIER, \"FUNCTION\"] IDENTIFIER ( expr_list )? )
				{
					DebugLocation(143, 84);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:84: ^( FUNCTION[$IDENTIFIER, \"FUNCTION\"] IDENTIFIER ( expr_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(143, 86);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION, IDENTIFIER35, "FUNCTION"), root_1);

					DebugLocation(143, 120);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
					DebugLocation(143, 131);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:131: ( expr_list )?
					if (stream_expr_list.HasNext)
					{
						DebugLocation(143, 131);
						adaptor.AddChild(root_1, stream_expr_list.NextTree());

					}
					stream_expr_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:144:4: ( MINUS INT )=> MINUS INT
				{
				DebugLocation(144, 19);
				MINUS39=(IToken)Match(input,MINUS,Follow._MINUS_in_atom972); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS39);

				DebugLocation(144, 25);
				INT40=(IToken)Match(input,INT,Follow._INT_in_atom974); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT40);



				{
				// AST REWRITE
				// elements: INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 144:29: -> ^( NEGATE[$MINUS, \"NEGATE\"] INT )
				{
					DebugLocation(144, 32);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:144:32: ^( NEGATE[$MINUS, \"NEGATE\"] INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(144, 34);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEGATE, MINUS39, "NEGATE"), root_1);

					DebugLocation(144, 59);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:145:4: LPARENTHESIS ( expr_seq )? RPARENTHESIS
				{
				DebugLocation(145, 4);
				LPARENTHESIS41=(IToken)Match(input,LPARENTHESIS,Follow._LPARENTHESIS_in_atom988); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPARENTHESIS.Add(LPARENTHESIS41);

				DebugLocation(145, 17);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:145:17: ( expr_seq )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==BREAK||LA11_0==FOR||(LA11_0>=IDENTIFIER && LA11_0<=IF)||LA11_0==INT||LA11_0==LET||LA11_0==LPARENTHESIS||LA11_0==MINUS||LA11_0==NIL||LA11_0==STRING||LA11_0==WHILE))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:145:17: expr_seq
					{
					DebugLocation(145, 17);
					PushFollow(Follow._expr_seq_in_atom990);
					expr_seq42=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq42.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(145, 27);
				RPARENTHESIS43=(IToken)Match(input,RPARENTHESIS,Follow._RPARENTHESIS_in_atom993); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPARENTHESIS.Add(RPARENTHESIS43);



				{
				// AST REWRITE
				// elements: expr_seq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 145:40: -> ^( EXPRESSION_SEQ[$LPARENTHESIS, \"EXPRESSION_SEQ\"] ( expr_seq )? )
				{
					DebugLocation(145, 43);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:145:43: ^( EXPRESSION_SEQ[$LPARENTHESIS, \"EXPRESSION_SEQ\"] ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(145, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_SEQ, LPARENTHESIS41, "EXPRESSION_SEQ"), root_1);

					DebugLocation(145, 93);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:145:93: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(145, 93);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:146:4: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(146, 4);
				INT44=(IToken)Match(input,INT,Follow._INT_in_atom1008); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT44_tree = (object)adaptor.Create(INT44);
				adaptor.AddChild(root_0, INT44_tree);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:147:4: NIL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(147, 4);
				NIL45=(IToken)Match(input,NIL,Follow._NIL_in_atom1013); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NIL45_tree = (object)adaptor.Create(NIL45);
				adaptor.AddChild(root_0, NIL45_tree);
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:148:4: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(148, 4);
				STRING46=(IToken)Match(input,STRING,Follow._STRING_in_atom1018); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING46_tree = (object)adaptor.Create(STRING46);
				adaptor.AddChild(root_0, STRING46_tree);
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:149:4: BREAK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(149, 4);
				BREAK47=(IToken)Match(input,BREAK,Follow._BREAK_in_atom1023); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BREAK47_tree = (object)adaptor.Create(BREAK47);
				adaptor.AddChild(root_0, BREAK47_tree);
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:150:4: MINUS lvalue
				{
				DebugLocation(150, 4);
				MINUS48=(IToken)Match(input,MINUS,Follow._MINUS_in_atom1028); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS48);

				DebugLocation(150, 10);
				PushFollow(Follow._lvalue_in_atom1030);
				lvalue49=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lvalue.Add(lvalue49.Tree);


				{
				// AST REWRITE
				// elements: lvalue
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 150:17: -> ^( NEGATE[$MINUS, \"NEGATE\"] lvalue )
				{
					DebugLocation(150, 20);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:150:20: ^( NEGATE[$MINUS, \"NEGATE\"] lvalue )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(150, 22);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEGATE, MINUS48, "NEGATE"), root_1);

					DebugLocation(150, 47);
					adaptor.AddChild(root_1, stream_lvalue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:151:4: lvalue
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(151, 4);
				PushFollow(Follow._lvalue_in_atom1044);
				lvalue50=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue50.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 6);
			LeaveRule("atom", 6);
			LeaveRule_atom();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_extensions();
	partial void LeaveRule_extensions();

	// $ANTLR start "extensions"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:153:1: extensions : ( DOT IDENTIFIER | LBRACKET expr RBRACKET -> ARRAY_INDEX[$LBRACKET, \"ARRAY_INDEX\"] expr );
	[GrammarRule("extensions")]
	private AstParserRuleReturnScope<object, IToken> extensions()
	{
		EnterRule_extensions();
		EnterRule("extensions", 7);
		TraceIn("extensions", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT51 = default(IToken);
		IToken IDENTIFIER52 = default(IToken);
		IToken LBRACKET53 = default(IToken);
		IToken RBRACKET55 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr54 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT51_tree = default(object);
		object IDENTIFIER52_tree = default(object);
		object LBRACKET53_tree = default(object);
		object RBRACKET55_tree = default(object);
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "extensions");
		DebugLocation(153, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:154:2: ( DOT IDENTIFIER | LBRACKET expr RBRACKET -> ARRAY_INDEX[$LBRACKET, \"ARRAY_INDEX\"] expr )
			int alt13=2;
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==DOT))
			{
				alt13 = 1;
			}
			else if ((LA13_0==LBRACKET))
			{
				alt13 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:154:4: DOT IDENTIFIER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(154, 4);
				DOT51=(IToken)Match(input,DOT,Follow._DOT_in_extensions1054); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DOT51_tree = (object)adaptor.Create(DOT51);
				adaptor.AddChild(root_0, DOT51_tree);
				}
				DebugLocation(154, 8);
				IDENTIFIER52=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_extensions1056); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IDENTIFIER52_tree = (object)adaptor.Create(IDENTIFIER52);
				adaptor.AddChild(root_0, IDENTIFIER52_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:155:4: LBRACKET expr RBRACKET
				{
				DebugLocation(155, 4);
				LBRACKET53=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_extensions1061); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET53);

				DebugLocation(155, 13);
				PushFollow(Follow._expr_in_extensions1063);
				expr54=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr54.Tree);
				DebugLocation(155, 18);
				RBRACKET55=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_extensions1065); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET55);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 155:27: -> ARRAY_INDEX[$LBRACKET, \"ARRAY_INDEX\"] expr
				{
					DebugLocation(155, 30);
					adaptor.AddChild(root_0, (object)adaptor.Create(ARRAY_INDEX, LBRACKET53, "ARRAY_INDEX"));
					DebugLocation(155, 68);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("extensions", 7);
			LeaveRule("extensions", 7);
			LeaveRule_extensions();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "extensions"); }
		return retval;

	}
	// $ANTLR end "extensions"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:1: lvalue : IDENTIFIER (others+= extensions )* -> ^( LVALUE[$IDENTIFIER, \"LVALUE\"] IDENTIFIER ( $others)* ) ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 8);
		TraceIn("lvalue", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENTIFIER56 = default(IToken);
		List<object> list_others = null;
		AstParserRuleReturnScope<object, IToken> others = default(AstParserRuleReturnScope<object, IToken>);
		object IDENTIFIER56_tree = default(object);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleSubtreeStream stream_extensions=new RewriteRuleSubtreeStream(adaptor,"rule extensions");
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(157, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:8: ( IDENTIFIER (others+= extensions )* -> ^( LVALUE[$IDENTIFIER, \"LVALUE\"] IDENTIFIER ( $others)* ) )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:10: IDENTIFIER (others+= extensions )*
			{
			DebugLocation(157, 10);
			IDENTIFIER56=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_lvalue1081); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER56);

			DebugLocation(157, 21);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:21: (others+= extensions )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==DOT||LA14_0==LBRACKET))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:22: others+= extensions
					{
					DebugLocation(157, 28);
					PushFollow(Follow._extensions_in_lvalue1086);
					others=extensions();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_extensions.Add(others.Tree);
					if (list_others==null) list_others=new List<object>();
					list_others.Add(others.Tree);


					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: IDENTIFIER, others
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: others
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_others=new RewriteRuleSubtreeStream(adaptor,"token others",list_others);
			root_0 = (object)adaptor.Nil();
			// 157:43: -> ^( LVALUE[$IDENTIFIER, \"LVALUE\"] IDENTIFIER ( $others)* )
			{
				DebugLocation(157, 46);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:46: ^( LVALUE[$IDENTIFIER, \"LVALUE\"] IDENTIFIER ( $others)* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(157, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LVALUE, IDENTIFIER56, "LVALUE"), root_1);

				DebugLocation(157, 78);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(157, 90);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:157:90: ( $others)*
				while ( stream_others.HasNext )
				{
					DebugLocation(157, 90);
					adaptor.AddChild(root_1, stream_others.NextTree());

				}
				stream_others.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 8);
			LeaveRule("lvalue", 8);
			LeaveRule_lvalue();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_flow_instructions();
	partial void LeaveRule_flow_instructions();

	// $ANTLR start "flow_instructions"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:159:1: flow_instructions : ( FOR IDENTIFIER ASSIGN a= expr TO b= expr DO c= expr -> ^( FOR IDENTIFIER $a $b $c) | LET declaration_list_wrapper IN ( expr_seq )? END -> ^( LET declaration_list_wrapper ^( EXPRESSION_SEQ[$IN, \"EXPRESSION_SEQ\"] ( expr_seq )? ) ) | WHILE ^ expr DO ! expr | ( IF expr THEN expr ELSE )=> IF a= expr THEN b= expr ELSE c= expr -> ^( IF_THEN_ELSE[$IF, \"IF_THEN_ELSE\"] $a $b $c) | IF a= expr THEN b= expr -> ^( IF_THEN[$IF, \"IF_THEN\"] $a $b) );
	[GrammarRule("flow_instructions")]
	private AstParserRuleReturnScope<object, IToken> flow_instructions()
	{
		EnterRule_flow_instructions();
		EnterRule("flow_instructions", 9);
		TraceIn("flow_instructions", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR57 = default(IToken);
		IToken IDENTIFIER58 = default(IToken);
		IToken ASSIGN59 = default(IToken);
		IToken TO60 = default(IToken);
		IToken DO61 = default(IToken);
		IToken LET62 = default(IToken);
		IToken IN64 = default(IToken);
		IToken END66 = default(IToken);
		IToken WHILE67 = default(IToken);
		IToken DO69 = default(IToken);
		IToken IF71 = default(IToken);
		IToken THEN72 = default(IToken);
		IToken ELSE73 = default(IToken);
		IToken IF74 = default(IToken);
		IToken THEN75 = default(IToken);
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> b = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> c = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_list_wrapper63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr68 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr70 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR57_tree = default(object);
		object IDENTIFIER58_tree = default(object);
		object ASSIGN59_tree = default(object);
		object TO60_tree = default(object);
		object DO61_tree = default(object);
		object LET62_tree = default(object);
		object IN64_tree = default(object);
		object END66_tree = default(object);
		object WHILE67_tree = default(object);
		object DO69_tree = default(object);
		object IF71_tree = default(object);
		object THEN72_tree = default(object);
		object ELSE73_tree = default(object);
		object IF74_tree = default(object);
		object THEN75_tree = default(object);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_TO=new RewriteRuleITokenStream(adaptor,"token TO");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_declaration_list_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule declaration_list_wrapper");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		try { DebugEnterRule(GrammarFileName, "flow_instructions");
		DebugLocation(159, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:160:2: ( FOR IDENTIFIER ASSIGN a= expr TO b= expr DO c= expr -> ^( FOR IDENTIFIER $a $b $c) | LET declaration_list_wrapper IN ( expr_seq )? END -> ^( LET declaration_list_wrapper ^( EXPRESSION_SEQ[$IN, \"EXPRESSION_SEQ\"] ( expr_seq )? ) ) | WHILE ^ expr DO ! expr | ( IF expr THEN expr ELSE )=> IF a= expr THEN b= expr ELSE c= expr -> ^( IF_THEN_ELSE[$IF, \"IF_THEN_ELSE\"] $a $b $c) | IF a= expr THEN b= expr -> ^( IF_THEN[$IF, \"IF_THEN\"] $a $b) )
			int alt16=5;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case FOR:
				{
				alt16 = 1;
				}
				break;
			case LET:
				{
				alt16 = 2;
				}
				break;
			case WHILE:
				{
				alt16 = 3;
				}
				break;
			case IF:
				{
				int LA16_4 = input.LA(2);

				if ((EvaluatePredicate(synpred7_Tiger_fragment)))
				{
					alt16 = 4;
				}
				else if ((true))
				{
					alt16 = 5;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 16, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:160:4: FOR IDENTIFIER ASSIGN a= expr TO b= expr DO c= expr
				{
				DebugLocation(160, 4);
				FOR57=(IToken)Match(input,FOR,Follow._FOR_in_flow_instructions1111); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FOR.Add(FOR57);

				DebugLocation(160, 8);
				IDENTIFIER58=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_flow_instructions1113); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER58);

				DebugLocation(160, 19);
				ASSIGN59=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_flow_instructions1115); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN59);

				DebugLocation(160, 27);
				PushFollow(Follow._expr_in_flow_instructions1119);
				a=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(a.Tree);
				DebugLocation(160, 33);
				TO60=(IToken)Match(input,TO,Follow._TO_in_flow_instructions1121); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TO.Add(TO60);

				DebugLocation(160, 37);
				PushFollow(Follow._expr_in_flow_instructions1125);
				b=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(b.Tree);
				DebugLocation(160, 43);
				DO61=(IToken)Match(input,DO,Follow._DO_in_flow_instructions1127); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DO.Add(DO61);

				DebugLocation(160, 47);
				PushFollow(Follow._expr_in_flow_instructions1131);
				c=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(c.Tree);


				{
				// AST REWRITE
				// elements: FOR, a, c, b, IDENTIFIER
				// token labels: 
				// rule labels: retval, b, c, a
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,"rule c",c!=null?c.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 160:53: -> ^( FOR IDENTIFIER $a $b $c)
				{
					DebugLocation(160, 56);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:160:56: ^( FOR IDENTIFIER $a $b $c)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(160, 58);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(160, 62);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
					DebugLocation(160, 74);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(160, 77);
					adaptor.AddChild(root_1, stream_b.NextTree());
					DebugLocation(160, 80);
					adaptor.AddChild(root_1, stream_c.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:4: LET declaration_list_wrapper IN ( expr_seq )? END
				{
				DebugLocation(161, 4);
				LET62=(IToken)Match(input,LET,Follow._LET_in_flow_instructions1153); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LET.Add(LET62);

				DebugLocation(161, 8);
				PushFollow(Follow._declaration_list_wrapper_in_flow_instructions1155);
				declaration_list_wrapper63=declaration_list_wrapper();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declaration_list_wrapper.Add(declaration_list_wrapper63.Tree);
				DebugLocation(161, 33);
				IN64=(IToken)Match(input,IN,Follow._IN_in_flow_instructions1157); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IN.Add(IN64);

				DebugLocation(161, 36);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:36: ( expr_seq )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==BREAK||LA15_0==FOR||(LA15_0>=IDENTIFIER && LA15_0<=IF)||LA15_0==INT||LA15_0==LET||LA15_0==LPARENTHESIS||LA15_0==MINUS||LA15_0==NIL||LA15_0==STRING||LA15_0==WHILE))
				{
					alt15 = 1;
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:36: expr_seq
					{
					DebugLocation(161, 36);
					PushFollow(Follow._expr_seq_in_flow_instructions1159);
					expr_seq65=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq65.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(15); }

				DebugLocation(161, 46);
				END66=(IToken)Match(input,END,Follow._END_in_flow_instructions1162); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_END.Add(END66);



				{
				// AST REWRITE
				// elements: LET, expr_seq, declaration_list_wrapper
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 161:50: -> ^( LET declaration_list_wrapper ^( EXPRESSION_SEQ[$IN, \"EXPRESSION_SEQ\"] ( expr_seq )? ) )
				{
					DebugLocation(161, 53);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:53: ^( LET declaration_list_wrapper ^( EXPRESSION_SEQ[$IN, \"EXPRESSION_SEQ\"] ( expr_seq )? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(161, 55);
					root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

					DebugLocation(161, 59);
					adaptor.AddChild(root_1, stream_declaration_list_wrapper.NextTree());
					DebugLocation(161, 84);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:84: ^( EXPRESSION_SEQ[$IN, \"EXPRESSION_SEQ\"] ( expr_seq )? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(161, 86);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_SEQ, IN64, "EXPRESSION_SEQ"), root_2);

					DebugLocation(161, 124);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:161:124: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(161, 124);
						adaptor.AddChild(root_2, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:162:4: WHILE ^ expr DO ! expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 9);
				WHILE67=(IToken)Match(input,WHILE,Follow._WHILE_in_flow_instructions1183); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WHILE67_tree = (object)adaptor.Create(WHILE67);
				root_0 = (object)adaptor.BecomeRoot(WHILE67_tree, root_0);
				}
				DebugLocation(162, 11);
				PushFollow(Follow._expr_in_flow_instructions1186);
				expr68=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr68.Tree);
				DebugLocation(162, 18);
				DO69=(IToken)Match(input,DO,Follow._DO_in_flow_instructions1188); if (state.failed) return retval;
				DebugLocation(162, 20);
				PushFollow(Follow._expr_in_flow_instructions1191);
				expr70=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr70.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:163:4: ( IF expr THEN expr ELSE )=> IF a= expr THEN b= expr ELSE c= expr
				{
				DebugLocation(163, 32);
				IF71=(IToken)Match(input,IF,Follow._IF_in_flow_instructions1210); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IF.Add(IF71);

				DebugLocation(163, 36);
				PushFollow(Follow._expr_in_flow_instructions1214);
				a=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(a.Tree);
				DebugLocation(163, 42);
				THEN72=(IToken)Match(input,THEN,Follow._THEN_in_flow_instructions1216); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_THEN.Add(THEN72);

				DebugLocation(163, 48);
				PushFollow(Follow._expr_in_flow_instructions1220);
				b=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(b.Tree);
				DebugLocation(163, 54);
				ELSE73=(IToken)Match(input,ELSE,Follow._ELSE_in_flow_instructions1222); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSE.Add(ELSE73);

				DebugLocation(163, 60);
				PushFollow(Follow._expr_in_flow_instructions1226);
				c=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(c.Tree);


				{
				// AST REWRITE
				// elements: c, b, a
				// token labels: 
				// rule labels: retval, b, c, a
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,"rule c",c!=null?c.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 163:66: -> ^( IF_THEN_ELSE[$IF, \"IF_THEN_ELSE\"] $a $b $c)
				{
					DebugLocation(163, 69);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:163:69: ^( IF_THEN_ELSE[$IF, \"IF_THEN_ELSE\"] $a $b $c)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(163, 71);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN_ELSE, IF71, "IF_THEN_ELSE"), root_1);

					DebugLocation(163, 106);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(163, 109);
					adaptor.AddChild(root_1, stream_b.NextTree());
					DebugLocation(163, 112);
					adaptor.AddChild(root_1, stream_c.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:164:4: IF a= expr THEN b= expr
				{
				DebugLocation(164, 4);
				IF74=(IToken)Match(input,IF,Follow._IF_in_flow_instructions1247); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IF.Add(IF74);

				DebugLocation(164, 8);
				PushFollow(Follow._expr_in_flow_instructions1251);
				a=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(a.Tree);
				DebugLocation(164, 14);
				THEN75=(IToken)Match(input,THEN,Follow._THEN_in_flow_instructions1253); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_THEN.Add(THEN75);

				DebugLocation(164, 20);
				PushFollow(Follow._expr_in_flow_instructions1257);
				b=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(b.Tree);


				{
				// AST REWRITE
				// elements: b, a
				// token labels: 
				// rule labels: retval, b, a
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 164:26: -> ^( IF_THEN[$IF, \"IF_THEN\"] $a $b)
				{
					DebugLocation(164, 29);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:164:29: ^( IF_THEN[$IF, \"IF_THEN\"] $a $b)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(164, 31);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN, IF74, "IF_THEN"), root_1);

					DebugLocation(164, 56);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(164, 59);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("flow_instructions", 9);
			LeaveRule("flow_instructions", 9);
			LeaveRule_flow_instructions();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "flow_instructions"); }
		return retval;

	}
	// $ANTLR end "flow_instructions"

	partial void EnterRule_field_list();
	partial void LeaveRule_field_list();

	// $ANTLR start "field_list"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:166:1: field_list : IDENTIFIER EQUAL a+= expr ( COMMA IDENTIFIER EQUAL a+= expr )* -> ( IDENTIFIER $a)+ ;
	[GrammarRule("field_list")]
	private AstParserRuleReturnScope<object, IToken> field_list()
	{
		EnterRule_field_list();
		EnterRule("field_list", 10);
		TraceIn("field_list", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENTIFIER76 = default(IToken);
		IToken EQUAL77 = default(IToken);
		IToken COMMA78 = default(IToken);
		IToken IDENTIFIER79 = default(IToken);
		IToken EQUAL80 = default(IToken);
		List<object> list_a = null;
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);
		object IDENTIFIER76_tree = default(object);
		object EQUAL77_tree = default(object);
		object COMMA78_tree = default(object);
		object IDENTIFIER79_tree = default(object);
		object EQUAL80_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "field_list");
		DebugLocation(166, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:167:2: ( IDENTIFIER EQUAL a+= expr ( COMMA IDENTIFIER EQUAL a+= expr )* -> ( IDENTIFIER $a)+ )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:167:4: IDENTIFIER EQUAL a+= expr ( COMMA IDENTIFIER EQUAL a+= expr )*
			{
			DebugLocation(167, 4);
			IDENTIFIER76=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_field_list1280); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER76);

			DebugLocation(167, 15);
			EQUAL77=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1282); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL77);

			DebugLocation(167, 22);
			PushFollow(Follow._expr_in_field_list1286);
			a=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(a.Tree);
			if (list_a==null) list_a=new List<object>();
			list_a.Add(a.Tree);

			DebugLocation(167, 29);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:167:29: ( COMMA IDENTIFIER EQUAL a+= expr )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==COMMA))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:167:30: COMMA IDENTIFIER EQUAL a+= expr
					{
					DebugLocation(167, 30);
					COMMA78=(IToken)Match(input,COMMA,Follow._COMMA_in_field_list1289); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA78);

					DebugLocation(167, 36);
					IDENTIFIER79=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_field_list1291); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER79);

					DebugLocation(167, 47);
					EQUAL80=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1293); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EQUAL.Add(EQUAL80);

					DebugLocation(167, 54);
					PushFollow(Follow._expr_in_field_list1297);
					a=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(a.Tree);
					if (list_a==null) list_a=new List<object>();
					list_a.Add(a.Tree);


					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: a, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (object)adaptor.Nil();
			// 167:63: -> ( IDENTIFIER $a)+
			{
				DebugLocation(167, 66);
				if (!(stream_a.HasNext||stream_IDENTIFIER.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.HasNext||stream_IDENTIFIER.HasNext )
				{
					DebugLocation(167, 67);
					adaptor.AddChild(root_0, stream_IDENTIFIER.NextNode());
					DebugLocation(167, 79);
					adaptor.AddChild(root_0, stream_a.NextTree());

				}
				stream_a.Reset();
				stream_IDENTIFIER.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_list", 10);
			LeaveRule("field_list", 10);
			LeaveRule_field_list();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "field_list"); }
		return retval;

	}
	// $ANTLR end "field_list"

	partial void EnterRule_expr_list();
	partial void LeaveRule_expr_list();

	// $ANTLR start "expr_list"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:169:1: expr_list : expr ( COMMA ! expr )* ;
	[GrammarRule("expr_list")]
	private AstParserRuleReturnScope<object, IToken> expr_list()
	{
		EnterRule_expr_list();
		EnterRule("expr_list", 11);
		TraceIn("expr_list", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA82 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr81 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr83 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA82_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_list");
		DebugLocation(169, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:170:2: ( expr ( COMMA ! expr )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:170:4: expr ( COMMA ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(170, 4);
			PushFollow(Follow._expr_in_expr_list1319);
			expr81=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr81.Tree);
			DebugLocation(170, 9);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:170:9: ( COMMA ! expr )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==COMMA))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:170:10: COMMA ! expr
					{
					DebugLocation(170, 15);
					COMMA82=(IToken)Match(input,COMMA,Follow._COMMA_in_expr_list1322); if (state.failed) return retval;
					DebugLocation(170, 17);
					PushFollow(Follow._expr_in_expr_list1325);
					expr83=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr83.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_list", 11);
			LeaveRule("expr_list", 11);
			LeaveRule_expr_list();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "expr_list"); }
		return retval;

	}
	// $ANTLR end "expr_list"

	partial void EnterRule_expr_seq();
	partial void LeaveRule_expr_seq();

	// $ANTLR start "expr_seq"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:172:1: expr_seq : expr ( SEMICOLON ! expr )* ;
	[GrammarRule("expr_seq")]
	private AstParserRuleReturnScope<object, IToken> expr_seq()
	{
		EnterRule_expr_seq();
		EnterRule("expr_seq", 12);
		TraceIn("expr_seq", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMICOLON85 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr84 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr86 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMICOLON85_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_seq");
		DebugLocation(172, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:172:9: ( expr ( SEMICOLON ! expr )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:172:11: expr ( SEMICOLON ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(172, 11);
			PushFollow(Follow._expr_in_expr_seq1335);
			expr84=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr84.Tree);
			DebugLocation(172, 16);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:172:16: ( SEMICOLON ! expr )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==SEMICOLON))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:172:17: SEMICOLON ! expr
					{
					DebugLocation(172, 26);
					SEMICOLON85=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_expr_seq1338); if (state.failed) return retval;
					DebugLocation(172, 28);
					PushFollow(Follow._expr_in_expr_seq1341);
					expr86=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr86.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_seq", 12);
			LeaveRule("expr_seq", 12);
			LeaveRule_expr_seq();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "expr_seq"); }
		return retval;

	}
	// $ANTLR end "expr_seq"

	partial void EnterRule_declaration_list_wrapper();
	partial void LeaveRule_declaration_list_wrapper();

	// $ANTLR start "declaration_list_wrapper"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:176:1: declaration_list_wrapper : ( declaration_list )+ ;
	[GrammarRule("declaration_list_wrapper")]
	private AstParserRuleReturnScope<object, IToken> declaration_list_wrapper()
	{
		EnterRule_declaration_list_wrapper();
		EnterRule("declaration_list_wrapper", 13);
		TraceIn("declaration_list_wrapper", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration_list87 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_list_wrapper");
		DebugLocation(176, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:177:2: ( ( declaration_list )+ )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:177:4: ( declaration_list )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(177, 4);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:177:4: ( declaration_list )+
			int cnt20=0;
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==FUNCTION||LA20_0==TYPE||LA20_0==VAR))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:177:4: declaration_list
					{
					DebugLocation(177, 4);
					PushFollow(Follow._declaration_list_in_declaration_list_wrapper1357);
					declaration_list87=declaration_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declaration_list87.Tree);

					}
					break;

				default:
					if (cnt20 >= 1)
						goto loop20;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee20 = new EarlyExitException( 20, input );
					DebugRecognitionException(eee20);
					throw eee20;
				}
				cnt20++;
			}
			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list_wrapper", 13);
			LeaveRule("declaration_list_wrapper", 13);
			LeaveRule_declaration_list_wrapper();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_list_wrapper"); }
		return retval;

	}
	// $ANTLR end "declaration_list_wrapper"

	partial void EnterRule_declaration_list();
	partial void LeaveRule_declaration_list();

	// $ANTLR start "declaration_list"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:179:1: declaration_list : ( type_declaration | variable_declaration_wrapper | function_declaration_wrapper );
	[GrammarRule("declaration_list")]
	private AstParserRuleReturnScope<object, IToken> declaration_list()
	{
		EnterRule_declaration_list();
		EnterRule("declaration_list", 14);
		TraceIn("declaration_list", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variable_declaration_wrapper89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_declaration_wrapper90 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_list");
		DebugLocation(179, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:180:2: ( type_declaration | variable_declaration_wrapper | function_declaration_wrapper )
			int alt21=3;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case TYPE:
				{
				alt21 = 1;
				}
				break;
			case VAR:
				{
				alt21 = 2;
				}
				break;
			case FUNCTION:
				{
				alt21 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:180:4: type_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(180, 4);
				PushFollow(Follow._type_declaration_in_declaration_list1368);
				type_declaration88=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration88.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:181:4: variable_declaration_wrapper
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(181, 4);
				PushFollow(Follow._variable_declaration_wrapper_in_declaration_list1373);
				variable_declaration_wrapper89=variable_declaration_wrapper();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration_wrapper89.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:182:4: function_declaration_wrapper
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(182, 4);
				PushFollow(Follow._function_declaration_wrapper_in_declaration_list1378);
				function_declaration_wrapper90=function_declaration_wrapper();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_declaration_wrapper90.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list", 14);
			LeaveRule("declaration_list", 14);
			LeaveRule_declaration_list();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_list"); }
		return retval;

	}
	// $ANTLR end "declaration_list"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:184:1: type_declaration : ( TYPE type_id EQUAL type )+ -> ( ^( TYPE_DECLARATION[$TYPE, \"TYPE_DECLARATION\"] type_id type ) )+ ;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 15);
		TraceIn("type_declaration", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE91 = default(IToken);
		IToken EQUAL93 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type94 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPE91_tree = default(object);
		object EQUAL93_tree = default(object);
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(184, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:185:2: ( ( TYPE type_id EQUAL type )+ -> ( ^( TYPE_DECLARATION[$TYPE, \"TYPE_DECLARATION\"] type_id type ) )+ )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:185:4: ( TYPE type_id EQUAL type )+
			{
			DebugLocation(185, 4);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:185:4: ( TYPE type_id EQUAL type )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==TYPE))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:185:5: TYPE type_id EQUAL type
					{
					DebugLocation(185, 5);
					TYPE91=(IToken)Match(input,TYPE,Follow._TYPE_in_type_declaration1389); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_TYPE.Add(TYPE91);

					DebugLocation(185, 10);
					PushFollow(Follow._type_id_in_type_declaration1391);
					type_id92=type_id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type_id.Add(type_id92.Tree);
					DebugLocation(185, 18);
					EQUAL93=(IToken)Match(input,EQUAL,Follow._EQUAL_in_type_declaration1393); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EQUAL.Add(EQUAL93);

					DebugLocation(185, 24);
					PushFollow(Follow._type_in_type_declaration1395);
					type94=type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type.Add(type94.Tree);

					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: type_id, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 185:31: -> ( ^( TYPE_DECLARATION[$TYPE, \"TYPE_DECLARATION\"] type_id type ) )+
			{
				DebugLocation(185, 34);
				if (!(stream_type_id.HasNext||stream_type.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_type_id.HasNext||stream_type.HasNext )
				{
					DebugLocation(185, 34);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:185:34: ^( TYPE_DECLARATION[$TYPE, \"TYPE_DECLARATION\"] type_id type )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(185, 36);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECLARATION, TYPE91, "TYPE_DECLARATION"), root_1);

					DebugLocation(185, 80);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(185, 88);
					adaptor.AddChild(root_1, stream_type.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				stream_type_id.Reset();
				stream_type.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 15);
			LeaveRule("type_declaration", 15);
			LeaveRule_type_declaration();
		}
		DebugLocation(186, 1);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:187:1: type : ( type_id -> ALIAS_TYPE_DECLARATION[((CommonTree)$type_id.tree).Token, \"ALIAS_TYPE_DECLARATION\"] type_id | LBRACE ( type_fields )? RBRACE -> RECORD_TYPE_DECLARATION[$LBRACE, \"RECORD_TYPE_DECLARATION\"] ( type_fields )? | ARRAY OF type_id -> ARRAY_TYPE_DECLARATION[$ARRAY, \"ARRAY_TYPE_DECLARATION\"] type_id );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 16);
		TraceIn("type", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE96 = default(IToken);
		IToken RBRACE98 = default(IToken);
		IToken ARRAY99 = default(IToken);
		IToken OF100 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_fields97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id101 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE96_tree = default(object);
		object RBRACE98_tree = default(object);
		object ARRAY99_tree = default(object);
		object OF100_tree = default(object);
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_ARRAY=new RewriteRuleITokenStream(adaptor,"token ARRAY");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(187, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:187:6: ( type_id -> ALIAS_TYPE_DECLARATION[((CommonTree)$type_id.tree).Token, \"ALIAS_TYPE_DECLARATION\"] type_id | LBRACE ( type_fields )? RBRACE -> RECORD_TYPE_DECLARATION[$LBRACE, \"RECORD_TYPE_DECLARATION\"] ( type_fields )? | ARRAY OF type_id -> ARRAY_TYPE_DECLARATION[$ARRAY, \"ARRAY_TYPE_DECLARATION\"] type_id )
			int alt24=3;
			try { DebugEnterDecision(24, false);
			switch (input.LA(1))
			{
			case IDENTIFIER:
				{
				alt24 = 1;
				}
				break;
			case LBRACE:
				{
				alt24 = 2;
				}
				break;
			case ARRAY:
				{
				alt24 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:187:8: type_id
				{
				DebugLocation(187, 8);
				PushFollow(Follow._type_id_in_type1418);
				type_id95=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id95.Tree);


				{
				// AST REWRITE
				// elements: type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 187:16: -> ALIAS_TYPE_DECLARATION[((CommonTree)$type_id.tree).Token, \"ALIAS_TYPE_DECLARATION\"] type_id
				{
					DebugLocation(187, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ALIAS_TYPE_DECLARATION, ((CommonTree)(type_id95!=null?((object)type_id95.Tree):default(object))).Token, "ALIAS_TYPE_DECLARATION"));
					DebugLocation(187, 103);
					adaptor.AddChild(root_0, stream_type_id.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:188:4: LBRACE ( type_fields )? RBRACE
				{
				DebugLocation(188, 4);
				LBRACE96=(IToken)Match(input,LBRACE,Follow._LBRACE_in_type1430); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(LBRACE96);

				DebugLocation(188, 11);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:188:11: ( type_fields )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==IDENTIFIER))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:188:11: type_fields
					{
					DebugLocation(188, 11);
					PushFollow(Follow._type_fields_in_type1432);
					type_fields97=type_fields();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type_fields.Add(type_fields97.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(188, 24);
				RBRACE98=(IToken)Match(input,RBRACE,Follow._RBRACE_in_type1435); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE98);



				{
				// AST REWRITE
				// elements: type_fields
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 188:31: -> RECORD_TYPE_DECLARATION[$LBRACE, \"RECORD_TYPE_DECLARATION\"] ( type_fields )?
				{
					DebugLocation(188, 34);
					adaptor.AddChild(root_0, (object)adaptor.Create(RECORD_TYPE_DECLARATION, LBRACE96, "RECORD_TYPE_DECLARATION"));
					DebugLocation(188, 94);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:188:94: ( type_fields )?
					if (stream_type_fields.HasNext)
					{
						DebugLocation(188, 94);
						adaptor.AddChild(root_0, stream_type_fields.NextTree());

					}
					stream_type_fields.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:189:4: ARRAY OF type_id
				{
				DebugLocation(189, 4);
				ARRAY99=(IToken)Match(input,ARRAY,Follow._ARRAY_in_type1448); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARRAY.Add(ARRAY99);

				DebugLocation(189, 10);
				OF100=(IToken)Match(input,OF,Follow._OF_in_type1450); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OF.Add(OF100);

				DebugLocation(189, 13);
				PushFollow(Follow._type_id_in_type1452);
				type_id101=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id101.Tree);


				{
				// AST REWRITE
				// elements: type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 189:21: -> ARRAY_TYPE_DECLARATION[$ARRAY, \"ARRAY_TYPE_DECLARATION\"] type_id
				{
					DebugLocation(189, 24);
					adaptor.AddChild(root_0, (object)adaptor.Create(ARRAY_TYPE_DECLARATION, ARRAY99, "ARRAY_TYPE_DECLARATION"));
					DebugLocation(189, 81);
					adaptor.AddChild(root_0, stream_type_id.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 16);
			LeaveRule("type", 16);
			LeaveRule_type();
		}
		DebugLocation(190, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:191:1: type_fields : type_field ( COMMA ! type_field )* ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 17);
		TraceIn("type_fields", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA103 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_field102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_field104 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA103_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(191, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:192:2: ( type_field ( COMMA ! type_field )* )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:192:4: type_field ( COMMA ! type_field )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(192, 4);
			PushFollow(Follow._type_field_in_type_fields1469);
			type_field102=type_field();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type_field102.Tree);
			DebugLocation(192, 15);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:192:15: ( COMMA ! type_field )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==COMMA))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:192:16: COMMA ! type_field
					{
					DebugLocation(192, 21);
					COMMA103=(IToken)Match(input,COMMA,Follow._COMMA_in_type_fields1472); if (state.failed) return retval;
					DebugLocation(192, 23);
					PushFollow(Follow._type_field_in_type_fields1475);
					type_field104=type_field();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, type_field104.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 17);
			LeaveRule("type_fields", 17);
			LeaveRule_type_fields();
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_type_field();
	partial void LeaveRule_type_field();

	// $ANTLR start "type_field"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:194:1: type_field : IDENTIFIER COLON type_id -> TYPE_DECLARATION_FIELD[$IDENTIFIER, \"TYPE_DECLARATION_FIELD\"] IDENTIFIER type_id ;
	[GrammarRule("type_field")]
	private AstParserRuleReturnScope<object, IToken> type_field()
	{
		EnterRule_type_field();
		EnterRule("type_field", 18);
		TraceIn("type_field", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENTIFIER105 = default(IToken);
		IToken COLON106 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id107 = default(AstParserRuleReturnScope<object, IToken>);

		object IDENTIFIER105_tree = default(object);
		object COLON106_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type_field");
		DebugLocation(194, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:195:2: ( IDENTIFIER COLON type_id -> TYPE_DECLARATION_FIELD[$IDENTIFIER, \"TYPE_DECLARATION_FIELD\"] IDENTIFIER type_id )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:195:4: IDENTIFIER COLON type_id
			{
			DebugLocation(195, 4);
			IDENTIFIER105=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_type_field1487); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER105);

			DebugLocation(195, 15);
			COLON106=(IToken)Match(input,COLON,Follow._COLON_in_type_field1489); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON106);

			DebugLocation(195, 21);
			PushFollow(Follow._type_id_in_type_field1491);
			type_id107=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id107.Tree);


			{
			// AST REWRITE
			// elements: IDENTIFIER, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 195:29: -> TYPE_DECLARATION_FIELD[$IDENTIFIER, \"TYPE_DECLARATION_FIELD\"] IDENTIFIER type_id
			{
				DebugLocation(195, 32);
				adaptor.AddChild(root_0, (object)adaptor.Create(TYPE_DECLARATION_FIELD, IDENTIFIER105, "TYPE_DECLARATION_FIELD"));
				DebugLocation(195, 94);
				adaptor.AddChild(root_0, stream_IDENTIFIER.NextNode());
				DebugLocation(195, 105);
				adaptor.AddChild(root_0, stream_type_id.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_field", 18);
			LeaveRule("type_field", 18);
			LeaveRule_type_field();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "type_field"); }
		return retval;

	}
	// $ANTLR end "type_field"

	partial void EnterRule_type_id();
	partial void LeaveRule_type_id();

	// $ANTLR start "type_id"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:197:1: type_id : IDENTIFIER ;
	[GrammarRule("type_id")]
	private AstParserRuleReturnScope<object, IToken> type_id()
	{
		EnterRule_type_id();
		EnterRule("type_id", 19);
		TraceIn("type_id", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENTIFIER108 = default(IToken);

		object IDENTIFIER108_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_id");
		DebugLocation(197, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:197:9: ( IDENTIFIER )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:197:11: IDENTIFIER
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(197, 11);
			IDENTIFIER108=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_type_id1509); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IDENTIFIER108_tree = (object)adaptor.Create(IDENTIFIER108);
			adaptor.AddChild(root_0, IDENTIFIER108_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_id", 19);
			LeaveRule("type_id", 19);
			LeaveRule_type_id();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "type_id"); }
		return retval;

	}
	// $ANTLR end "type_id"

	partial void EnterRule_variable_declaration_wrapper();
	partial void LeaveRule_variable_declaration_wrapper();

	// $ANTLR start "variable_declaration_wrapper"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:199:1: variable_declaration_wrapper : ( variable_declaration )+ ;
	[GrammarRule("variable_declaration_wrapper")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration_wrapper()
	{
		EnterRule_variable_declaration_wrapper();
		EnterRule("variable_declaration_wrapper", 20);
		TraceIn("variable_declaration_wrapper", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variable_declaration109 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "variable_declaration_wrapper");
		DebugLocation(199, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:200:2: ( ( variable_declaration )+ )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:200:4: ( variable_declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(200, 4);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:200:4: ( variable_declaration )+
			int cnt26=0;
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==VAR))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:200:4: variable_declaration
					{
					DebugLocation(200, 4);
					PushFollow(Follow._variable_declaration_in_variable_declaration_wrapper1519);
					variable_declaration109=variable_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration109.Tree);

					}
					break;

				default:
					if (cnt26 >= 1)
						goto loop26;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee26 = new EarlyExitException( 26, input );
					DebugRecognitionException(eee26);
					throw eee26;
				}
				cnt26++;
			}
			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration_wrapper", 20);
			LeaveRule("variable_declaration_wrapper", 20);
			LeaveRule_variable_declaration_wrapper();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration_wrapper"); }
		return retval;

	}
	// $ANTLR end "variable_declaration_wrapper"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:202:1: variable_declaration : VAR IDENTIFIER ( COLON type_id )? ASSIGN expr -> ^( VAR_DECLARATION[$VAR, \"VAR_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? expr ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 21);
		TraceIn("variable_declaration", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR110 = default(IToken);
		IToken IDENTIFIER111 = default(IToken);
		IToken COLON112 = default(IToken);
		IToken ASSIGN114 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id113 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr115 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR110_tree = default(object);
		object IDENTIFIER111_tree = default(object);
		object COLON112_tree = default(object);
		object ASSIGN114_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(202, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:2: ( VAR IDENTIFIER ( COLON type_id )? ASSIGN expr -> ^( VAR_DECLARATION[$VAR, \"VAR_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? expr ) )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:4: VAR IDENTIFIER ( COLON type_id )? ASSIGN expr
			{
			DebugLocation(203, 4);
			VAR110=(IToken)Match(input,VAR,Follow._VAR_in_variable_declaration1530); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VAR.Add(VAR110);

			DebugLocation(203, 8);
			IDENTIFIER111=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_variable_declaration1532); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER111);

			DebugLocation(203, 19);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:19: ( COLON type_id )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==COLON))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:20: COLON type_id
				{
				DebugLocation(203, 20);
				COLON112=(IToken)Match(input,COLON,Follow._COLON_in_variable_declaration1535); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON112);

				DebugLocation(203, 26);
				PushFollow(Follow._type_id_in_variable_declaration1537);
				type_id113=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id113.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(203, 36);
			ASSIGN114=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration1541); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN114);

			DebugLocation(203, 43);
			PushFollow(Follow._expr_in_variable_declaration1543);
			expr115=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr115.Tree);


			{
			// AST REWRITE
			// elements: expr, IDENTIFIER, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 203:48: -> ^( VAR_DECLARATION[$VAR, \"VAR_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? expr )
			{
				DebugLocation(203, 51);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:51: ^( VAR_DECLARATION[$VAR, \"VAR_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(203, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DECLARATION, VAR110, "VAR_DECLARATION"), root_1);

				DebugLocation(203, 94);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(203, 105);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:203:105: ( RETURN_TYPE type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(203, 106);
					adaptor.AddChild(root_1, (object)adaptor.Create(RETURN_TYPE, "RETURN_TYPE"));
					DebugLocation(203, 118);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(203, 128);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 21);
			LeaveRule("variable_declaration", 21);
			LeaveRule_variable_declaration();
		}
		DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_function_declaration_wrapper();
	partial void LeaveRule_function_declaration_wrapper();

	// $ANTLR start "function_declaration_wrapper"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:205:1: function_declaration_wrapper : ( function_declaration )+ ;
	[GrammarRule("function_declaration_wrapper")]
	private AstParserRuleReturnScope<object, IToken> function_declaration_wrapper()
	{
		EnterRule_function_declaration_wrapper();
		EnterRule("function_declaration_wrapper", 22);
		TraceIn("function_declaration_wrapper", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> function_declaration116 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "function_declaration_wrapper");
		DebugLocation(205, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:206:2: ( ( function_declaration )+ )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:206:4: ( function_declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(206, 4);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:206:4: ( function_declaration )+
			int cnt28=0;
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==FUNCTION))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:206:4: function_declaration
					{
					DebugLocation(206, 4);
					PushFollow(Follow._function_declaration_in_function_declaration_wrapper1571);
					function_declaration116=function_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, function_declaration116.Tree);

					}
					break;

				default:
					if (cnt28 >= 1)
						goto loop28;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee28 = new EarlyExitException( 28, input );
					DebugRecognitionException(eee28);
					throw eee28;
				}
				cnt28++;
			}
			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration_wrapper", 22);
			LeaveRule("function_declaration_wrapper", 22);
			LeaveRule_function_declaration_wrapper();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "function_declaration_wrapper"); }
		return retval;

	}
	// $ANTLR end "function_declaration_wrapper"

	partial void EnterRule_function_declaration();
	partial void LeaveRule_function_declaration();

	// $ANTLR start "function_declaration"
	// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:208:1: function_declaration : FUNCTION IDENTIFIER LPARENTHESIS ( type_fields )? RPARENTHESIS ( COLON type_id )? EQUAL expr -> ^( FUNCTION_DECLARATION[$FUNCTION, \"FUNCTION_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? ( type_fields )? expr ) ;
	[GrammarRule("function_declaration")]
	private AstParserRuleReturnScope<object, IToken> function_declaration()
	{
		EnterRule_function_declaration();
		EnterRule("function_declaration", 23);
		TraceIn("function_declaration", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION117 = default(IToken);
		IToken IDENTIFIER118 = default(IToken);
		IToken LPARENTHESIS119 = default(IToken);
		IToken RPARENTHESIS121 = default(IToken);
		IToken COLON122 = default(IToken);
		IToken EQUAL124 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_fields120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id123 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr125 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION117_tree = default(object);
		object IDENTIFIER118_tree = default(object);
		object LPARENTHESIS119_tree = default(object);
		object RPARENTHESIS121_tree = default(object);
		object COLON122_tree = default(object);
		object EQUAL124_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_RPARENTHESIS=new RewriteRuleITokenStream(adaptor,"token RPARENTHESIS");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPARENTHESIS=new RewriteRuleITokenStream(adaptor,"token LPARENTHESIS");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "function_declaration");
		DebugLocation(208, 1);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:2: ( FUNCTION IDENTIFIER LPARENTHESIS ( type_fields )? RPARENTHESIS ( COLON type_id )? EQUAL expr -> ^( FUNCTION_DECLARATION[$FUNCTION, \"FUNCTION_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? ( type_fields )? expr ) )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:4: FUNCTION IDENTIFIER LPARENTHESIS ( type_fields )? RPARENTHESIS ( COLON type_id )? EQUAL expr
			{
			DebugLocation(209, 4);
			FUNCTION117=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_function_declaration1582); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION117);

			DebugLocation(209, 13);
			IDENTIFIER118=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_function_declaration1584); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER118);

			DebugLocation(209, 24);
			LPARENTHESIS119=(IToken)Match(input,LPARENTHESIS,Follow._LPARENTHESIS_in_function_declaration1586); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPARENTHESIS.Add(LPARENTHESIS119);

			DebugLocation(209, 37);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:37: ( type_fields )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==IDENTIFIER))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:37: type_fields
				{
				DebugLocation(209, 37);
				PushFollow(Follow._type_fields_in_function_declaration1588);
				type_fields120=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields120.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(209, 50);
			RPARENTHESIS121=(IToken)Match(input,RPARENTHESIS,Follow._RPARENTHESIS_in_function_declaration1591); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPARENTHESIS.Add(RPARENTHESIS121);

			DebugLocation(209, 63);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:63: ( COLON type_id )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_0 = input.LA(1);

			if ((LA30_0==COLON))
			{
				alt30 = 1;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:64: COLON type_id
				{
				DebugLocation(209, 64);
				COLON122=(IToken)Match(input,COLON,Follow._COLON_in_function_declaration1594); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON122);

				DebugLocation(209, 70);
				PushFollow(Follow._type_id_in_function_declaration1596);
				type_id123=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id123.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(209, 80);
			EQUAL124=(IToken)Match(input,EQUAL,Follow._EQUAL_in_function_declaration1600); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL124);

			DebugLocation(209, 86);
			PushFollow(Follow._expr_in_function_declaration1602);
			expr125=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr125.Tree);


			{
			// AST REWRITE
			// elements: type_fields, type_id, expr, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 209:91: -> ^( FUNCTION_DECLARATION[$FUNCTION, \"FUNCTION_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? ( type_fields )? expr )
			{
				DebugLocation(209, 94);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:94: ^( FUNCTION_DECLARATION[$FUNCTION, \"FUNCTION_DECLARATION\"] IDENTIFIER ( RETURN_TYPE type_id )? ( type_fields )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(209, 96);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DECLARATION, FUNCTION117, "FUNCTION_DECLARATION"), root_1);

				DebugLocation(209, 152);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(209, 163);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:163: ( RETURN_TYPE type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(209, 164);
					adaptor.AddChild(root_1, (object)adaptor.Create(RETURN_TYPE, "RETURN_TYPE"));
					DebugLocation(209, 176);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(209, 186);
				// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:209:186: ( type_fields )?
				if (stream_type_fields.HasNext)
				{
					DebugLocation(209, 186);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

				}
				stream_type_fields.Reset();
				DebugLocation(209, 199);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration", 23);
			LeaveRule("function_declaration", 23);
			LeaveRule_function_declaration();
		}
		DebugLocation(210, 1);
		} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
		return retval;

	}
	// $ANTLR end "function_declaration"

	partial void EnterRule_synpred2_Tiger_fragment();
	partial void LeaveRule_synpred2_Tiger_fragment();

	// $ANTLR start synpred2_Tiger
	public void synpred2_Tiger_fragment()
	{
		EnterRule_synpred2_Tiger_fragment();
		EnterRule("synpred2_Tiger_fragment", 25);
		TraceIn("synpred2_Tiger_fragment", 25);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:140:4: ( lvalue ASSIGN )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:140:5: lvalue ASSIGN
			{
			DebugLocation(140, 5);
			PushFollow(Follow._lvalue_in_synpred2_Tiger826);
			lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(140, 12);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred2_Tiger828); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_Tiger_fragment", 25);
			LeaveRule("synpred2_Tiger_fragment", 25);
			LeaveRule_synpred2_Tiger_fragment();
		}
	}
	// $ANTLR end synpred2_Tiger

	partial void EnterRule_synpred3_Tiger_fragment();
	partial void LeaveRule_synpred3_Tiger_fragment();

	// $ANTLR start synpred3_Tiger
	public void synpred3_Tiger_fragment()
	{
		EnterRule_synpred3_Tiger_fragment();
		EnterRule("synpred3_Tiger_fragment", 26);
		TraceIn("synpred3_Tiger_fragment", 26);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:4: ( type_id LBRACE )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:141:5: type_id LBRACE
			{
			DebugLocation(141, 5);
			PushFollow(Follow._type_id_in_synpred3_Tiger853);
			type_id();
			PopFollow();
			if (state.failed) return;
			DebugLocation(141, 13);
			Match(input,LBRACE,Follow._LBRACE_in_synpred3_Tiger855); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_Tiger_fragment", 26);
			LeaveRule("synpred3_Tiger_fragment", 26);
			LeaveRule_synpred3_Tiger_fragment();
		}
	}
	// $ANTLR end synpred3_Tiger

	partial void EnterRule_synpred4_Tiger_fragment();
	partial void LeaveRule_synpred4_Tiger_fragment();

	// $ANTLR start synpred4_Tiger
	public void synpred4_Tiger_fragment()
	{
		EnterRule_synpred4_Tiger_fragment();
		EnterRule("synpred4_Tiger_fragment", 27);
		TraceIn("synpred4_Tiger_fragment", 27);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:142:4: ( type_id LBRACKET expr RBRACKET OF )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:142:5: type_id LBRACKET expr RBRACKET OF
			{
			DebugLocation(142, 5);
			PushFollow(Follow._type_id_in_synpred4_Tiger885);
			type_id();
			PopFollow();
			if (state.failed) return;
			DebugLocation(142, 13);
			Match(input,LBRACKET,Follow._LBRACKET_in_synpred4_Tiger887); if (state.failed) return;
			DebugLocation(142, 22);
			PushFollow(Follow._expr_in_synpred4_Tiger889);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(142, 27);
			Match(input,RBRACKET,Follow._RBRACKET_in_synpred4_Tiger891); if (state.failed) return;
			DebugLocation(142, 36);
			Match(input,OF,Follow._OF_in_synpred4_Tiger893); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_Tiger_fragment", 27);
			LeaveRule("synpred4_Tiger_fragment", 27);
			LeaveRule_synpred4_Tiger_fragment();
		}
	}
	// $ANTLR end synpred4_Tiger

	partial void EnterRule_synpred5_Tiger_fragment();
	partial void LeaveRule_synpred5_Tiger_fragment();

	// $ANTLR start synpred5_Tiger
	public void synpred5_Tiger_fragment()
	{
		EnterRule_synpred5_Tiger_fragment();
		EnterRule("synpred5_Tiger_fragment", 28);
		TraceIn("synpred5_Tiger_fragment", 28);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:4: ( IDENTIFIER LPARENTHESIS )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:143:5: IDENTIFIER LPARENTHESIS
			{
			DebugLocation(143, 5);
			Match(input,IDENTIFIER,Follow._IDENTIFIER_in_synpred5_Tiger933); if (state.failed) return;
			DebugLocation(143, 16);
			Match(input,LPARENTHESIS,Follow._LPARENTHESIS_in_synpred5_Tiger935); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_Tiger_fragment", 28);
			LeaveRule("synpred5_Tiger_fragment", 28);
			LeaveRule_synpred5_Tiger_fragment();
		}
	}
	// $ANTLR end synpred5_Tiger

	partial void EnterRule_synpred6_Tiger_fragment();
	partial void LeaveRule_synpred6_Tiger_fragment();

	// $ANTLR start synpred6_Tiger
	public void synpred6_Tiger_fragment()
	{
		EnterRule_synpred6_Tiger_fragment();
		EnterRule("synpred6_Tiger_fragment", 29);
		TraceIn("synpred6_Tiger_fragment", 29);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:144:4: ( MINUS INT )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:144:5: MINUS INT
			{
			DebugLocation(144, 5);
			Match(input,MINUS,Follow._MINUS_in_synpred6_Tiger965); if (state.failed) return;
			DebugLocation(144, 11);
			Match(input,INT,Follow._INT_in_synpred6_Tiger967); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_Tiger_fragment", 29);
			LeaveRule("synpred6_Tiger_fragment", 29);
			LeaveRule_synpred6_Tiger_fragment();
		}
	}
	// $ANTLR end synpred6_Tiger

	partial void EnterRule_synpred7_Tiger_fragment();
	partial void LeaveRule_synpred7_Tiger_fragment();

	// $ANTLR start synpred7_Tiger
	public void synpred7_Tiger_fragment()
	{
		EnterRule_synpred7_Tiger_fragment();
		EnterRule("synpred7_Tiger_fragment", 30);
		TraceIn("synpred7_Tiger_fragment", 30);
		try
		{
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:163:4: ( IF expr THEN expr ELSE )
			DebugEnterAlt(1);
			// D:\\Programing\\Projects\\TigerCompiler\\TigerGrammar\\Tiger.g:163:5: IF expr THEN expr ELSE
			{
			DebugLocation(163, 5);
			Match(input,IF,Follow._IF_in_synpred7_Tiger1197); if (state.failed) return;
			DebugLocation(163, 8);
			PushFollow(Follow._expr_in_synpred7_Tiger1199);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(163, 13);
			Match(input,THEN,Follow._THEN_in_synpred7_Tiger1201); if (state.failed) return;
			DebugLocation(163, 18);
			PushFollow(Follow._expr_in_synpred7_Tiger1203);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(163, 23);
			Match(input,ELSE,Follow._ELSE_in_synpred7_Tiger1205); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_Tiger_fragment", 30);
			LeaveRule("synpred7_Tiger_fragment", 30);
			LeaveRule_synpred7_Tiger_fragment();
		}
	}
	// $ANTLR end synpred7_Tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_program685 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conjunction_term_in_expr704 = new BitSet(new ulong[]{0x2000000000022UL});
		public static readonly BitSet _OR_in_expr708 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _AND_in_expr711 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _conjunction_term_in_expr715 = new BitSet(new ulong[]{0x2000000000022UL});
		public static readonly BitSet _comparison_term_in_conjunction_term727 = new BitSet(new ulong[]{0x806018100002UL});
		public static readonly BitSet _EQUAL_in_conjunction_term731 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _NOT_EQUAL_in_conjunction_term734 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _LESS_THAN_in_conjunction_term737 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _GREATER_THAN_in_conjunction_term740 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _LESS_EQUAL_THAN_in_conjunction_term743 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _GREATER_EQUAL_THAN_in_conjunction_term746 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _comparison_term_in_conjunction_term750 = new BitSet(new ulong[]{0x806018100002UL});
		public static readonly BitSet _term_in_comparison_term762 = new BitSet(new ulong[]{0x4080000000002UL});
		public static readonly BitSet _PLUS_in_comparison_term766 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _MINUS_in_comparison_term769 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _term_in_comparison_term773 = new BitSet(new ulong[]{0x4080000000002UL});
		public static readonly BitSet _atom_in_term796 = new BitSet(new ulong[]{0x100000008002UL});
		public static readonly BitSet _MULT_in_term800 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _DIV_in_term805 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _atom_in_term809 = new BitSet(new ulong[]{0x100000008002UL});
		public static readonly BitSet _flow_instructions_in_atom820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_atom833 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_atom835 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_atom837 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_atom860 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _LBRACE_in_atom862 = new BitSet(new ulong[]{0x8000020000000UL});
		public static readonly BitSet _field_list_in_atom864 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _RBRACE_in_atom867 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_atom898 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _LBRACKET_in_atom900 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_atom904 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _RBRACKET_in_atom906 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _OF_in_atom908 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_atom912 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_atom940 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _LPARENTHESIS_in_atom942 = new BitSet(new ulong[]{0x5004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_list_in_atom944 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPARENTHESIS_in_atom947 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_atom972 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _INT_in_atom974 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPARENTHESIS_in_atom988 = new BitSet(new ulong[]{0x5004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_seq_in_atom990 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPARENTHESIS_in_atom993 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_atom1008 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NIL_in_atom1013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_atom1018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_atom1023 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_atom1028 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _lvalue_in_atom1030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_atom1044 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_extensions1054 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IDENTIFIER_in_extensions1056 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_extensions1061 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_extensions1063 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _RBRACKET_in_extensions1065 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_lvalue1081 = new BitSet(new ulong[]{0x1000020002UL});
		public static readonly BitSet _extensions_in_lvalue1086 = new BitSet(new ulong[]{0x1000020002UL});
		public static readonly BitSet _FOR_in_flow_instructions1111 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IDENTIFIER_in_flow_instructions1113 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_flow_instructions1115 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1119 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _TO_in_flow_instructions1121 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1125 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _DO_in_flow_instructions1127 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_flow_instructions1153 = new BitSet(new ulong[]{0x2000000002000000UL,0x1UL});
		public static readonly BitSet _declaration_list_wrapper_in_flow_instructions1155 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _IN_in_flow_instructions1157 = new BitSet(new ulong[]{0x4004A8461080400UL,0x4UL});
		public static readonly BitSet _expr_seq_in_flow_instructions1159 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _END_in_flow_instructions1162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_flow_instructions1183 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1186 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _DO_in_flow_instructions1188 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_flow_instructions1210 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1214 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _THEN_in_flow_instructions1216 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1220 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ELSE_in_flow_instructions1222 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_flow_instructions1247 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1251 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _THEN_in_flow_instructions1253 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_flow_instructions1257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_field_list1280 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQUAL_in_field_list1282 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_field_list1286 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_field_list1289 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IDENTIFIER_in_field_list1291 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQUAL_in_field_list1293 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_field_list1297 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _expr_in_expr_list1319 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_expr_list1322 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_expr_list1325 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _expr_in_expr_seq1335 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _SEMICOLON_in_expr_seq1338 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_expr_seq1341 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _declaration_list_in_declaration_list_wrapper1357 = new BitSet(new ulong[]{0x2000000002000002UL,0x1UL});
		public static readonly BitSet _type_declaration_in_declaration_list1368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_wrapper_in_declaration_list1373 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_declaration_wrapper_in_declaration_list1378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_type_declaration1389 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_id_in_type_declaration1391 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQUAL_in_type_declaration1393 = new BitSet(new ulong[]{0x820000040UL});
		public static readonly BitSet _type_in_type_declaration1395 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _type_id_in_type1418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_type1430 = new BitSet(new ulong[]{0x8000020000000UL});
		public static readonly BitSet _type_fields_in_type1432 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _RBRACE_in_type1435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAY_in_type1448 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _OF_in_type1450 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_id_in_type1452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_field_in_type_fields1469 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_type_fields1472 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_field_in_type_fields1475 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _IDENTIFIER_in_type_field1487 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _COLON_in_type_field1489 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_id_in_type_field1491 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_type_id1509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_variable_declaration_wrapper1519 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _VAR_in_variable_declaration1530 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IDENTIFIER_in_variable_declaration1532 = new BitSet(new ulong[]{0xA00UL});
		public static readonly BitSet _COLON_in_variable_declaration1535 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_id_in_variable_declaration1537 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration1541 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_variable_declaration1543 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_declaration_in_function_declaration_wrapper1571 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _FUNCTION_in_function_declaration1582 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IDENTIFIER_in_function_declaration1584 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _LPARENTHESIS_in_function_declaration1586 = new BitSet(new ulong[]{0x100000020000000UL});
		public static readonly BitSet _type_fields_in_function_declaration1588 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPARENTHESIS_in_function_declaration1591 = new BitSet(new ulong[]{0x100800UL});
		public static readonly BitSet _COLON_in_function_declaration1594 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _type_id_in_function_declaration1596 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQUAL_in_function_declaration1600 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_function_declaration1602 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred2_Tiger826 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_synpred2_Tiger828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_synpred3_Tiger853 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _LBRACE_in_synpred3_Tiger855 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_synpred4_Tiger885 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _LBRACKET_in_synpred4_Tiger887 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_synpred4_Tiger889 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _RBRACKET_in_synpred4_Tiger891 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _OF_in_synpred4_Tiger893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_synpred5_Tiger933 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _LPARENTHESIS_in_synpred5_Tiger935 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_synpred6_Tiger965 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _INT_in_synpred6_Tiger967 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_synpred7_Tiger1197 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_synpred7_Tiger1199 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _THEN_in_synpred7_Tiger1201 = new BitSet(new ulong[]{0x4004A8461000400UL,0x4UL});
		public static readonly BitSet _expr_in_synpred7_Tiger1203 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ELSE_in_synpred7_Tiger1205 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
